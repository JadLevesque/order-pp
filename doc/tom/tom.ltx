% (C) Copyright Vesa Karvonen 2004.
%
% Distributed under the Boost Software License, Version 1.0.

\documentclass[10pt,a4paper]{report}

\usepackage{graphicx,syntax,url}

\setlength{\grammarparsep}{3pt}
\setlength{\grammarindent}{5em}

\begin{document}

%% Title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{headings}
\pagenumbering{roman}

\author{Vesa~Karvonen}
\title{The Order Metalanguage for C Preprocessor Metaprogramming\\
  \bigskip
  WORKING DRAFT}

\maketitle

%% Copyright %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

{\footnotesize \raggedright

\copyright{} Copyright Vesa Karvonen 2004.

\smallskip

Distributed under the Boost Software License, Version 1.0.

\bigskip

{\large Boost Software License - Version 1.0 - August 17th, 2003}

\medskip

Permission is hereby granted, free of charge, to any person or
organization obtaining a copy of the software and accompanying
documentation covered by this license (the ``Software'') to use,
reproduce, display, distribute, execute, and transmit the Software,
and to prepare derivative works of the Software, and to permit
third-parties to whom the Software is furnished to do so, all
subject to the following:

\smallskip

The copyright notices in the Software and this entire statement,
including the above license grant, this restriction and the
following disclaimer, must be included in all copies of the
Software, in whole or in part, and all derivative works of the
Software, unless such copies or derivative works are solely in the
form of machine-executable object code generated by a source
language processor.

\smallskip

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.}

%% Preface %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

Order grew out of my interest in the design of programming languages
and metaprogramming as well as desire to make something original,
fascinating and beautiful. My work on the Boost.Preprocessor library
\cite{boost.pp} had left me unsatisfied. While it was clear to me
that it could theoretically be used to implement \emph{useful}
non--trivial metaprograms, it would have been quite tedious work,
full of nasty little details and limitations to trip you up. I
considered the prospects for further enhancements to the library,
but it didn't seem possible to provide a programming model that I
would have considered pleasant to think in. It occured to me that
instead of attempting to provide semimodular enhancements on top of
the C preprocessor in a bottom--up fashion, it might be possible to
lift the limitations by designing a complete monolithic interpreter
for a high--level source language in a top--down fashion. After some
experiments at interpreting lambda calculus and a couple of
prototype interpreters for early versions of the Order language, I
was left with a feeling that it would be too inefficient to be
practical. The most serious limitation seemed to be the inability of
the early prototypes to generate arbitrary output efficiently. I
decided to forget about the interpreter and move on, but the work
proved too interesting for me to forget completely. Over a long
period of time I found several small incremental improvements to the
interpreter until it suddenly started to look like more than a
theoretical curiosity. Then I knew I just had to finish the work.
Hopefully everyone will be able to find some beauty in the result.
At least I know I've had a lot of fun designing the language.

\subsection*{Intent}

This book introduces the complete Order language and prelude and
presents several complete examples of using the Order language.
While this isn't a formal definition of the Order language, key
constructs of the language will be given approximate\footnote{The C
preprocessor macro replacement mechanism will not be modelled
completely.} formal specifications. The main purpose of presenting
the semantics is to show that the Order language is actually very
much like any ordinary programming language. While the
implementation of the Order interpreter has required working through
a considerable number of technical obstacles, we will largely ignore
such low--level details and concentrate on the high--level design
and use of the language.

\subsection*{Audience}

This book is written for programmers working on C and C++ projects
who would like to use metaprogramming techniques in their work. The
reader should be familiar with the C and C++ programming language
and have a basic understanding of the C preprocessor. Previous
knowledge of lambda calculus and functional programming will help
understanding the material.

\subsection*{Electronic Resources}

The latest releases of the Order interpreter and documentation can
be found at the Chaos preprocessor SourceForge project:
\url{http://sourceforge.net/projects/chaos-pp}.

\subsection*{Acknowledgements}

I wish to thank Paul Mensonides, who discovered many of the C
preprocessor programming techniques used in the Order interpreter
and the prelude. He also provided the project space for constructing
the Order interpreter and participated in many intense discussions
related to C preprocessor programming. Without Paul's contributions,
the Order interpreter wouldn't exist today.

\bigskip

{\raggedright Vesa Karvonen}

%% Table of Contents %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\tableofcontents

%% Body %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\setcounter{page}{1}
\pagenumbering{arabic}

\chapter{Introduction} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter gives a minimal overview of the main features of the
Order language and interpreter and puts it into perspective as a
metalanguage of the C preprocessor. The last section of this chapter
is an example using the Order interpreter.

\section{What is Order?} %******************************************

Order is a \emph{complete} programming language designed to be
\emph{interpreted} using the \emph{C preprocessor} \cite{c:1999}.
Rather than being a general purpose language, Order is a
\emph{metalanguage}, that can be used to \emph{generate} sequences
of \emph{preprocessing tokens}.

Order is a \emph{high--level} \emph{functional} language with
\emph{call--by--value} semantics, providing \emph{first--class
anonymous functions} with \emph{lexically scoped variables} and
supporting \emph{partial application} of functions. The Order
interpreter is implemented in \emph{continuation passing style} and
is fully \emph{tail recursive}. Order is a \emph{reflective}
language providing \emph{first class continuations}, \emph{first
class environments} and an \emph{eval} function. Memory management
in Order is implicit. Order provides \emph{arbitrary--precision
arithmetic} on natural numbers, a comprehensive set of primitive and
\emph{higher--order} functions for an aggregate data type called
\emph{sequence} and \emph{more}.\footnote{If you are not familiar
with some of the terms used here, rest assured, all will become
clear.}

Order is a fairly simple language to learn. It has only a modest
number of syntactic forms with simple semantics and is based on
the \emph{lambda calculus}.\footnote{Programmers familiar with both
Scheme \cite{dybvig:1996,abelson:1996} and SML, in addition to C and
the C preprocessor, should find Order particularly easy to learn.}
Compared to other C preprocessor metaprogramming systems, such as
the Boost Preprocessor library \cite{boost.pp}, Order provides a
clearly higher--level alternative. Rather than providing some
enhancements over the plain C preprocessor designed one problem at a
time, Order implements a complete solution at once.

\section{The C Preprocessor} %**************************************

The C preprocessor (Cpp) is part of both C \cite{c:1999} and C++
\cite{c++:1998} and is mainly used to compose \emph{translation
units} out of \emph{source files} using the \url{#include} directive
and a family of conditional directives (\url{#if}, \url{#ifdef},
\ldots, \url{#endif}). The Cpp is a \emph{low--level}
\emph{macroprocessor} enabling the definition of \emph{object--like}
and \emph{function--like} macros using the \url{#define}
directive.\footnote{The Cpp also has some other features and uses,
but they are not relevant to Order.} The Order interpreter is
implemented using the macro mechanism of the Cpp.

The preprocessor defined by the C standard includes a number of
important extensions, namely \emph{variadic} macros and
\emph{placemarkers}, that aren't provided by standard C++. Apart
from those extensions, and a few minor differences, the C and C++
preprocessors are essentially the same and many modern C++
implementations actually provide variadic macros and placemarkers as
an extension as they are likely to be adopted into the next C++
standard.

Bjarne Stroustrup, the inventor of C++, has said that ``I'd like to
see Cpp abolished'' \cite{stroustrup:1994}. Indeed, many consider
the Cpp to be one of the \emph{worst} macroprocessors in history and
for good reasons. We will assume that the reader is all too familiar
with the problems \cite{stroustrup:1994} and we will only discuss
issues that are directly relevant to our subject.

The main strength of the Cpp is that it comes with every standards
conforming C and C++ implementation. Compared to external
metaprogramming facilities for C and C++, Cpp ``Works out of the
box.'' This strength should not be underestimated. Library authors,
and programmers in general, would often like to use generative
programming techniques \cite{czarnecki:2000,graham:1993}. However,
code generation with external, non--standard tools introduces a host
of problems typically making the maintenance, distribution and
porting of software much harder.

As implied, the macro mechanism of the Cpp hasn't been designed to
be very powerful. It explicitly disallows recursion by implementing
a \emph{name disabling} scheme, which marks recursively generated
macro names as disabled from macro replacement.\footnote{The include
mechanism can be used recursively, but it is much too low--level a
mechanism to be used for anything non--trivial.} The macro mechanism
also doesn't directly support repetition of any kind. Despite these
limitations, and the fact that the Cpp macro mechanism can't get
into an infinite loop, it has turned out that the Cpp macro
mechanism is, from a practical point of view, \emph{Turing complete}
\cite{lewis:1998}, being capable of evaluating arbitrary algorithms
for any predefined number of computational steps using an evaluator
consisting of a number of macros logarithmic to the number of
computational steps. The practical computational completeness of the
Cpp opens up the possibility of using the Cpp for non--trivial
\emph{code generation}.

Before we continue, let's put the strong claim of practical Turing
completeness into perspective. Let's assume that one would like to
empirically verify the incompleteness of the current Order
interpreter. To do this, one would design a program that
\emph{should}, according to the hypothesis, eventually fail due to
running out of computational steps.\footnote{An infinite loop would
do the trick.} For the sake of getting some concrete numbers, let's
further assume that a Cpp implementation would exists that could
perform 1 billion (1000000000) macro replacements per second, which
should be more than an order of magnitude more than the fastest
uniprocessors are capable of today.\footnote{It is unlikely that the
Cpp would significantly benefit from a massively parallel
architecture.} As one can easily check, the concrete machine used by
the current Order interpreter can perform exactly $2^{65}-1$
computational steps and each step takes at least two macro
replacements. Based on these numbers, and a simple series of
divides, we can predict that if one would start the program today,
one would have to wait more than 2000 years for the failure. Of
course, the Order interpreter could easily be extended with a couple
of hundred macros to prolong the wait well beyond the estimated
lifetime of the sun\footnote{10 billion years, according to some
sources.}. The point of all this is to assure the reader that the
theoretical computational incompleteness of the Order interpreter is
the last thing to worry about. A correct Order program may
definitely fail to preprocess, but it is unlikely to happen due to
the computational incompleteness of the Order interpreter.

\input{bottles.ltx} %***********************************************

\chapter{Getting Started} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter explains how to get started with experimenting with the
Order interpreter.

\section{Requirements} %********************************************

The Order interpreter, which is fully \cite{c:1999} conforming, has
been developed with the GNU CPP version 3.x and contains no
workarounds for broken preprocessors. The Order interpreter
\emph{requires variadics and placemarkers} as defined in
\cite{c:1999}. The Wave preprocessor \cite{kaiser:2002} is also
known to be able to preprocess Order. A standards conforming
C preprocessor and a fast computer with plenty of memory is
recommended for experimenting with the interpreter. Be aware that
despite the simplicity of the C preprocessor and the existence
of stable standard for years and years, many preprocessors are
broken beyond repair, either strictly not conforming to the standard
or employing macro replacement algorithms that seem to take at least
exponential time.

\section{The Interactive Test Shell} %******************************

The interpreter comes with a simple Bash--shell script\footnote{The
script also makes use of some standard commands such as \emph{grep},
\emph{sed} and \emph{head}. You'll probably have those commands if
you have the Bash--shell.} that can be used for writing simple
regression tests and interactive evaluation of Order expressions.
The \url{test-shell} script can be found in the \url{test}
directory.

When you start the test shell by typing \url{./test-shell}, the
script first tries to find a preprocessor to use and will ask you
which preprocessor you wish to use:
\begin{verbatim}
Choose preprocessor [cpp] ?
\end{verbatim}
You must type in the name of the preprocessor you want to use.
\begin{verbatim}
Choose preprocessor [cpp] ? cpp
Wrote cpp to the .preprocessor file.
\end{verbatim}
The default is saved to a configuration file. To change the default,
you need to remove the configuration file.

It then greets you with the main menu:
\begin{verbatim}
Database: test.db
Backed up database to: test.db.bak
[(A)dd | (C)lean | (D)ebug | (M)ode: 0 | (Q)uit | (S)how | (T)est | Eval]?
\end{verbatim}

To make a selection in the menus, press a single key. The default
action can be activated with any key other than the explicitly
assigned keys for non--default actions. In the main menu above, the
\url{Eval}--action is the default action.

Most of the test shell should be quite intuitive. To run all the
tests, you can press \url{t} in the main menu, and assuming you have
a conforming preprocessor, you should see something like this:
\begin{verbatim}
Running 338 tests...
Time: 0.461 seconds
\end{verbatim}

To evaluate an expression just press enter (any key will do) in the
main menu and you'll get the prompt:
\begin{verbatim}
Term:
\end{verbatim}
You can now type an expression to evaluate. For example, you could
type:
\begin{verbatim}
Term: 8add(20,3)
\end{verbatim}
and then press enter to see:
\begin{verbatim}
Time: 0.082 seconds
Result: 23
\end{verbatim}
which shows that it took \verb/0.082 seconds/\footnote{Most of that
time is overhead of starting the C preprocessor.} to evaluate the
expression and the result of the expression was \url{23}.

If you make a typo, the C preprocessor may essentially eat all memory
causing your computer to become unresponsive. In such a case you can
safely hit \url{Ctrl-C} to break the C preprocessor and then restart
the test shell. In most cases, however, a typo simply causes garbage
output. The test shell does not immediately display the result
unless it fits within one line. This helps to avoid having to watch
(hundreds of) thousands of garbage tokens scroll through.
Theoretically, the Order interpreter can generate output whose
length is counted in billions of billions of tokens. Most likely
your computer runs out of memory before that many tokens are
generated.

The debug command of the main menu is used to trace the execution of
Order programs at the \emph{continuation machine} level. It is
mostly useful for debugging the interpreter itself, but it can be
useful for the purpose of understanding how the interpreter actually
works.\footnote{The primary purpose of the test shell is to simplify
testing the interpreter.}

The mode flag in the main menu refers to the use of the built--in
\emph{debug mode} of the interpreter. In the debug mode, the
interpreter performs some additional syntax and type checks. These
checks are normally disabled, but they can greatly help to pinpoint
errors in programs during development.

You should now be ready to follow the introduction to the Order
language with the help of the interactive test shell. Please do try
out expressions explained in the rest of this document using the
test shell. Of course, you can also prepare a CPP source file to try
the Order interpreter, but using the test shell for trying out
simple expressions is probably much quicker. For longer programs,
involving definitions, you will need to create CPP source files.

\chapter{Extended Examples} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{binary.ltx}

\input{array-ops.ltx}

\appendix %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Bibliography %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\bibliographystyle{alpha}
\bibliography{bibliography}
\addcontentsline{toc}{chapter}{Bibliography}

\end{document}
