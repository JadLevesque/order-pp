        <exp> ::= <def-const>                                        ;; constant reference
               |  <def-fn>                                           ;; function reference
               |  <def-fn>({<exp>}+{,})                              ;; function application
               |  <def-op>({<exp>}+{,})                              ;; operator application
               |  <var>                                              ;; variable reference
               |  `8'                                                ;; constant `8'
               |  `8'(<pp-arg>)                                      ;; quote abbreviation
               |  `8and'({<exp>}+{,})                                ;; logical AND
               |  `8ap'({<exp>}+{,})                                 ;; application
               |  `8cond'({<cond-clause>}+)                          ;; gen. conditional
               |  `8delay'(<exp>)                                    ;; closure
               |  `8do'({<exp>}+{,})                                 ;; sequencing
               |  `8fn'({<sym>}+{,}, <exp>)                          ;; lambda abstraction
               |  `8if'(<exp_cond>, <exp_cons>, {<exp_alt>}+{,})     ;; conditional
               |  `8let'({(<sym>, <exp_init>)}+, {<exp_body>}+{,})   ;; binding
               |  `8letn'({(<sym>, <exp_init>)}+, {<exp_body>}+{,})  ;; nested binding
               |  `8or'({<exp>}+{,})                                 ;; logical OR
               |  `8print'({<print-exp>}+)                           ;; output expression
               |  `8quote'(<pp-arg>)                                 ;; quotation
               |  `8ref'(<sym>)                                      ;; symbol reference
               |  `8remap'(<exp_fn>, <lit_n>{, {<lit_i>}+{,}}?)      ;; reparameterization
               |  `8seq'                                             ;; nil constructor
               |  `8seq'({<exp>}+{,})                                ;; sequence constructor
               |  `8tuple'({<exp>}+{,})                              ;; tuple constructor

<cond-clause> ::= (<exp_cond>, {<exp_cons>}+{,})                     ;; conditionally taken
               |  (`8else', {<exp_cons>}+{,})                        ;; always taken

  <print-exp> ::= (<pp-args>)                                        ;; output verbatim
               |  <exp>                                              ;; output value
               |  `8comma'                                           ;; output comma
               |  `8lparen'                                          ;; output left-paren
               |  `8parens'({<print-exp>}+)                          ;; output parenthesized
               |  `8rparen'                                          ;; output right-paren
               |  `8space'                                           ;; output space

        <sym> ::= [`0'-`9'][`0'-`9'`A'-`Z'`a'-`z'`_']*               ;; general symbol

        <var> ::= `8'[`A'-`Z']                                       ;; variable symbol
