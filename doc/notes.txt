==========================================================================

  (C) Copyright Vesa Karvonen 2004.
 
  Distributed under the Boost Software License, Version 1.0.

==========================================================================

                                  NOTE
                                  ====

     These DESIGN NOTES are not intended to serve as documentation.

==========================================================================

SYNTAX
======

  <exp>
   ::= 8fn(<sym>+, <exp>)
     | 8ap(<exp>+)
     | <var>
     | 8ref(<sym>)
     | 8if(<exp_{cond}>, <exp_{cons}>, <exp_{alt}>)
     | 8and(<exp>+)
     | 8or(<exp>+)
     | 8do(<exp>+)
     | 8let({<var>, <exp_{init}>}+, <exp_{body}>)
     | 8match(<exp_{val}>, {<pat>, <exp>}+)
     | 8try(<exp_{body}>, <var>, <exp_{handler}>)
     | <fn>
     | <fn>(<exp>+)
     | <op>(<exp>+)
     | <const>

  <var>
   ::= 8[A-Z]

  <sym>
   ::= [0-9][a-zA-Z0-9_]*

  <pat>
   ::= 8tuple(<pat>+{,rest(<var|_>)}?)
     | 8seq(<pat>+{,rest(<var|_>)}?)
     | <ctor>
     | <ctor>(<pat>+)
     | 8nil
     | <var>                         ;; Matches anything and bings <var>
     | 8_                            ;;     -- || --     and binds nothing

--------------------------------------------------------------------------

DEFINITIONS <#define ORDER_PP_DEF_>
-----------

Order should support various kinds of definitions for ease-of-use.

  <name> ORDER_PP_CONST(<pp-param>)

Defines a named constant. The expression ''<name>'' then evaluates to
''<pp-param>''. Constant definitions can also be function-like macros, but
except for the highly useful ''quote(<pp-param>)'' there probably aren't
many uses for such definitions.

It should also be possible to get the value of a constant so that it can
be embedded into another constant. This is necessary to avoid having to
manually duplicate information accross constants. For this purpose, a
macro ''ORDER_PP_GET_CONST(<name>)'' should be defined.

  <name>(<pp-args>) ORDER_PP_MACRO(<exp>)

Defines a "macro". The effect is that an expression of the form
''<name>(<params>)'' is macro replaced to ''<exp>''. The interpreter then
evaluates the ''<exp>''. Macros are efficient, because the macro
replacement doesn't take an additional continuation machine step. Macros
can not be partially applied and may cause surprises.

  <name> ORDER_PP_FN(<exp_{fn}>)
  <name> ORDER_PP_FN_CM(<arity>, <instr>)
  <name> ORDER_PP_FN_MACRO(<arity>, <macro>)
  <name> ORDER_PP_FN_NATIVE(<arity>, <macro>)

Each of the above defines a function. Functions take their arguments
one-by-one and have a fixed arity.

  <name> ORDER_PP_OP(<assoc>,<pp-param_{unit}>,<exp_{fn}>)
  <name> ORDER_PP_OP_CM(<assoc>,<pp-param_{unit}>,<instr>)
  <name> ORDER_PP_OP_MACRO(<assoc>,<pp-param_{unit}>,<macro>)
  <name> ORDER_PP_OP_NATIVE(<assoc>,<pp-param_{unit}>,<macro>)

Each of the above defines an operator. Operators take all of their
arguments immediately and they can not be applied partially. The
associativity of an operator is one of:

  left      | left-associative            | op(... op(x1,x2) ..., xn)
  left_w_1  | left-associative with unit  | op(... op( 1,x1) ..., xn)
  right     | right-associative           | op(xn, ... op(x2,x1) ...)
  right_w_1 | right-associative with unit | op(xn, ... op(x1, 1) ...)

The unit element is unused when associativity is ''left'' or ''right''.

--------------------------------------------------------------------------

DATA TYPES
==========

Aggregate Types
---------------

Order should support at least tuples and sequences. Tuples are required
for passing parameters to macros and are generally useful as input syntax.
Sequences are more efficient than lists and are also syntactically
simpler.

Tuples should only require a small number of first-order functions.

Sequences should come with a fairly comprehensive set of optimized
functions, in order to enable decent performance.

Strings
-------

TBD!

Set, Mat and Priority Queue
---------------------------

More advanced program generators are going to need sets, maps and priority
queues. (For string processing, a trie might also be useful.)

TBD!

--------------------------------------------------------------------------

BUILTINS
========

   8fn(s0, s1, ..., sN, b)
   8ap(f, x1, ..., xN)
   8ref(s)

   8quote(x)
   8(x)
   8

   8let(s, i, b)

   8do(x0, x1, ..., xN)
   8rout(x0, x1, ..., xN)

   8if(b, c, a)
   8and(x0, x1, ..., xN)
   8or(x0, x1, ..., xN)

   8cat(x0, x1, ..., xN)

   8seq(x0, x1, ..., xN)
   8tuple(x0, x1, ..., xN)

   8print(syntax)

STANDARD PRELUDE
================

Arithmetic
----------

   {0, ..., 7, 9, ..., 100} : Lit

   8to_lit(n)            : Num -> Lit

   8nat(d0, d1, ..., dN) : Nat

   8dec(n)               : Num -> Num
   8inc(n)               : Num -> Num

   8add(n0, n1, ..., nN) : Num+ -> Num
   8div(n0, n1, ..., nN) : Num+ -> Num
   8mul(n0, n1, ..., nN) : Num+ -> Num
   8sub(n0, n1, ..., nN) : Num+ -> Num

   8minus(ln, rn)        : Num -> Num -> Num
   8plus(ln, rn)         : Num -> Num -> Num
   8quotient(ln, rn)     : Num -> Num -> Num
   8remainder(ln, rn)    : Num -> Num -> Num
   8times(ln, rn)        : Num -> Num -> Num

   8is_0(n)              : Num -> Bool
   8isnt_0(n)            : Num -> Bool

   8equal(ln, rn)        : Num -> Num -> Bool
   8not_eq(ln, rn)       : Num -> Num -> Bool

   8greater(ln, rn)      : Num -> Num -> Bool
   8greater_eq(ln, rn)   : Num -> Num -> Bool
   8less(ln, rn)         : Num -> Num -> Bool
   8less_eq(ln, rn)      : Num -> Num -> Bool

Boolean
-------

   8true  : Bool
   8false : Bool

   8not(x) : Bool -> Bool

Control
-------

   8call_cc(fn)  : ((Any -> Any) -> Any) -> Any

   8eval(exp, env) : Exp -> Env -> Any

   8exit(x) : Any -> Any

   8for_each(x, cn, st, op) : (Any -> Bool) -> (Any -> Any) -> (Any -> Nil) -> Any -> Nil

   8for_each_in_range(i0, i1, op) : Num -> Num -> (Num -> Nil) -> Nil

   8while(x, cn, st) : Any -> (Any -> Bool) -> (Any -> Any) -> Any
   8until(x, cn, st) : Any -> (Any -> Bool) -> (Any -> Any) -> Any

   8unless(<exp_{cond}>, <exp_{body}>+)
   8when(<exp_{cond}>, <exp_{body}>+)

   8with_assert(<exp_{cond}>, <exp_{body}>)

Environments
------------

   8env_nil                  : Env

   8env_bind(e, s, x)        : Env -> Sym -> Any -> Env
   8env_ref(e, s)            : Env -> Sym -> Any

   8env_to_seq_of_pairs(e)   : Env -> Seq
   8seq_of_pairs_to_env(s)   : Seq -> Env

  -8env_has(e, s)            : Env -> Sym -> Bool
  -8env_drop(e, s)           : Env -> Sym -> Env
  -8env_join(le, re)         : Env -> Env -> Env

Functional primitives
---------------------

   8apply(f, t) : (Any+ -> Any) -> Tuple -> Any

   8chain(f0, f1, ..., fN) : (Any -> Any)+ -> (Any -> Any)

   8compose(f, g) : (Any -> Any) -> (Any -> Any) -> (Any -> Any)

   8identity(x) : Any -> Any

   8ignore(x) : Any -> Nil

Nil
---

   8nil : Nil

   8is_nil(x) : Any -> Bool

Output
------

   8put(x) : Any -> Nil

   8emit(m, p) : Any -> Any -> Nil

   8emit_comma(x)  : Any -> Nil
   8emit_lparen(x) : Any -> Nil
   8emit_rparen(x) : Any -> Nil

   8emit_params(i0, i1, p)          : Num -> Num -> Any -> Nil
   8emit_trailing_params(i0, i1, p) : Num -> Num -> Any -> Nil

Preprocessing
-------------

   8expand(m, p)   : Any -> Any -> Any

   8adjacent(l, r) : Any -> Any -> Any
   8separate(l, r) : Any -> Any -> Any

   8paste(l, r)    : Any -> Any -> Any

   8stringize(x)   : Any -> Any

Symbols
-------

   8is_sym(x) : Any -> Bool

   8same(x, y)     : Any -> Any -> Bool
   8not_same(x, y) : Any -> Any -> Bool

Sequences
---------

  Constants:

   8seq_nil                       : Seq

  Predicates:

   8seq_is_nil(s)                 : Seq -> Bool
   8seq_isnt_nil(s)               : Seq -> Bool

  Operators:

   8seq_append(s0, s1, ..., sN)   : Seq+ -> Seq

  First-order:

   8seq_at(i, s)                  : Num -> Seq -> Any
   8seq_set(i, s, x)              : Num -> Seq -> Any -> Seq
   8seq_range(i, n, s)            : Num -> Num -> Seq -> Seq

   8seq_first(s)                  : Seq -> Any
   8seq_rest(s)                   : Seq -> Seq

   8seq_first_n(n, s)             : Num -> Seq -> Seq
   8seq_rest_n(n, s)              : Num -> Seq -> Seq

   8seq_size(s)                   : Seq -> Num

   8seq_reverse(s)                : Seq -> Seq

   8seq_pop_at(i, s)              : Num -> Seq -> Seq
   8seq_pop_back(s)               : Seq -> Seq
   8seq_pop_front(s)              : Seq -> Seq
  -8seq_pop_range(i, n, s)        : Num -> Num -> Seq -> Seq

   8seq_push_at(i, s, x)          : Num -> Seq -> Any -> Seq
   8seq_push_back(x, s)           : Any -> Seq -> Seq
   8seq_push_front(x, s)          : Any -> Seq -> Any -> Seq
  -8seq_push_range(i, s, ss)      : Num -> Seq -> Seq -> Seq

   8seq_split(i, s)               : Num -> Seq -> Tuple(Seq, Seq)
   8seq_join(ls, rs)              : Seq -> Seq -> Seq

   8seq_to_tuple(s)               : Seq -> Tuple

  Higher-order:

   8seq_fold(fn, x, s)               : (Any -> Any -> Any) -> Any -> Seq -> Any
   8seq_unfold(x, cn, st, fn)        : Any -> (Any -> Bool) -> (Any -> Any) -> (Any -> Any) -> Seq

   8seq_filter(pr, s)                : (Any -> Bool) -> Seq -> Seq

   8seq_for_each(op, s)              : (Any -> Nil) -> Seq -> Nil
   8seq_for_each_in_product(op, ss)  : (Any+ -> Nil) -> Seq(Seq) -> Nil
   8seq_for_each_with_idx(op, s)     : (Num -> Any -> Nil) -> Seq -> Nil
  -8seq_for_each_perm(op, s)         : (Seq -> Nil) -> Seq -> Nil

   8seq_map(fn, s)                   : (Any -> Any) -> Seq -> Seq

   8seq_merge(pr, los, ros)          : (Any -> Any -> Bool) -> Seq -> Seq -> Seq
   8seq_merge_sort(pr, s)            : (Any -> Any -> Bool) -> Seq -> Seq

   8seq_partition(pr, s)             : (Any -> Bool) -> Seq -> Tuple(Seq, Seq)
   8seq_partition_sort(pr, s)        : (Any -> Any -> Bool) -> Seq -> Seq

  -8seq_is_sorted(pr, s)             : (Any -> Any -> Bool) -> Seq -> Bool
   8seq_sort(pr, s)                  : (Any -> Any -> Bool) -> Seq -> Seq

  -8seq_unique(pr, os)               : (Any -> Any -> Bool) -> Seq -> Seq

   8seq_select(pr, x, s)             : (Any -> Any -> Bool) -> Any -> Seq -> Any

   8seq_exists(pr, s)                : (Any -> Bool) -> Seq -> Bool
   8seq_for_all(pr, s)               : (Any -> Bool) -> Seq -> Bool

  -8seq_zip(ls, rs)                  : Seq -> Seq -> Seq

  -8seq_count(pr, s)                 : (Any -> Bool) -> Seq -> Num

  -8seq_lin_search(pr, s)            : (Any -> Bool) -> Seq -> Tuple(Seq, Seq)

  -8seq_diff(pr, los, ros)           : (Any -> Any -> Bool) -> Seq -> Seq -> Seq
  -8seq_insert(pr, x, os)            : (Any -> Any -> Bool) -> Any -> Seq -> Seq
  -8seq_inters(pr, los, ros)         : (Any -> Any -> Bool) -> Seq -> Seq -> Seq
  -8seq_symm_diff(pr, los, ros)      : (Any -> Any -> Bool) -> Seq -> Seq -> Seq
  -8seq_union(pr, los, ros)          : (Any -> Any -> Bool) -> Seq -> Seq -> Seq

  -8seq_bin_search(pr, s)            : (Any -> Bool) -> Seq -> Tuple(Seq, Seq)

Tuples
------

   8is_tuple(x)         : Any -> Bool

   8pair(l, r)          : Any -> Any -> Tuple

   8tuple_at(i, t)      : Num -> Tuple -> Any
   8tuple_at_[0,9](t)   : Tuple -> Any

   8tuple_rest(t)       : Tuple -> Tuple
   8tuple_rest_n(n, t)  : Num -> Tuple -> Tuple
   8tuple_rest_[1-9](t) : Num -> Tuple -> Tuple

   8tuple_size(t)       : Tuple -> Num

   8tuple_to_seq(t)     : Tuple -> Seq

--------------------------------------------------------------------------

LIBRARIES
=========

  "enum.h":

  "string.h":
