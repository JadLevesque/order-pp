==========================================================================

(C) Copyright Vesa Karvonen 2004.
 
     Distributed under the Boost Software License, Version 1.0.

==========================================================================

                                  NOTE
                                  ====

     These DESIGN NOTES are not intended to serve as documentation.

==========================================================================

SYNTAX
======

  <exp>
   ::= 8fn(<var>+, <exp>)
     | 8ap(<exp>+)
     | <var>
     | 8if(<exp_{cond}>, <exp_{cons}>, <exp_{alt}>)
     | 8and(<exp>+)
     | 8or(<exp>+)
     | 8do(<exp>+)
     | 8let({<var>, <exp_{init}>}+, <exp_{body}>)
     | 8for(<var>, <exp_{init}>, <exp_{cond}>, <exp_{step}>, <exp>+)
     | 8match(<exp_{val}>, {<pat>, <exp>}+)
     | 8try(<exp_{body}>, <var>, <exp_{handler}>)
     | <fn>
     | <fn>(<exp>+)
     | <op>(<exp>+)
     | <const>

  <var>
   ::= 8[A-Z][a-z0-9]?

  <pat>
   ::= 8tuple(<pat>+{,rest(<var|_>)}?)
     | 8seq(<pat>+{,rest(<var|_>)}?)
     | <ctor>
     | <ctor>(<pat>+)
     | 8nil
     | <var>                         ;; Matches anything and bings <var>
     | 8_                            ;;     -- || --     and binds nothing

--------------------------------------------------------------------------

DEFINITIONS <#define ORDER_PP_DEF_>
-----------

Order should support various kinds of definitions for ease-of-use.

  <name> ORDER_PP_CONST(<pp-param>)

Defines a named constant. The expression ''<name>'' then evaluates to
''<pp-param>''. Constant definitions can also be function-like macros, but
except for the highly useful ''quote(<pp-param>)'' there probably aren't
many uses for such definitions.

It should also be possible to get the value of a constant so that it can
be embedded into another constant. This is necessary to avoid having to
manually duplicate information accross constants. For this purpose, a
macro ''ORDER_PP_GET_CONST(<name>)'' should be defined.

  <name>(<pp-args>) ORDER_PP_MACRO(<exp>)

Defines a "macro". The effect is that an expression of the form
''<name>(<params>)'' is macro replaced to ''<exp>''. The interpreter then
evaluates the ''<exp>''. Macros are efficient, because the macro
replacement doesn't take an additional continuation machine step. Macros
can not be partially applied and may cause surprises.

  <name> ORDER_PP_FN(<exp_{fn}>)
  <name> ORDER_PP_FN_CM(<arity>, <instr>, (,<cont>))
  <name> ORDER_PP_FN_MACRO(<arity>, <macro>)
  <name> ORDER_PP_FN_MACRO_P(<arity>, <macro>)

Each of the above defines a function. Functions take their arguments
one-by-one and have a fixed arity.

  <name> ORDER_PP_OP(<assoc>,<pp-param_{unit}>,<exp_{fn}>)
  <name> ORDER_PP_OP_CM(<assoc>,<pp-param_{unit}>,<instr>,(,<cont>))
  <name> ORDER_PP_OP_MACRO(<assoc>,<pp-param_{unit}>,<macro>)
  <name> ORDER_PP_OP_MACRO_P(<assoc>,<pp-param_{unit}>,<macro>)

Each of the above defines an operator. Operators take all of their
arguments immediately and they can not be applied partially. The
associativity of an operator is one of:

  left      | left-associative            | op(... op(x1,x2) ..., xn)
  left_w_1  | left-associative with unit  | op(... op( 1,x1) ..., xn)
  right     | right-associative           | op(xn, ... op(x2,x1) ...)
  right_w_1 | right-associative with unit | op(xn, ... op(x1, 1) ...)

The unit element is unused when associativity is ''left'' or ''right''.

--------------------------------------------------------------------------

DATA TYPES
==========

Aggregate Types
---------------

Order should support at least tuples and sequences. Tuples are required
for passing parameters to macros and are generally useful as input syntax.
Sequences are more efficient than lists and are also syntactically
simpler.

Tuples should only require a small number of first-order functions.

Sequences should come with a fairly comprehensive set of optimized
functions, in order to enable decent performance. The first-order
functions could be borrowed from Chaos.

Strings
-------

TBD!

Set, Mat and Priority Queue
---------------------------

More advanced program generators are going to need sets, maps and priority
queues. (For string processing, a trie might also be useful.)

TBD!

--------------------------------------------------------------------------

STANDARD PRELUDE
================

Constants
---------

   {0,...,256} : Num

   8true  : Bool
   8false : Bool

   8nil : Nil

Operators
---------

   8add(8N1,...,8NN) : Num+ -> Num
   8sub(8N1,...,8NN) : Num+ -> Num
   8mul(8N1,...,8NN) : Num+ -> Num
   8div(8N1,...,8NN) : Num+ -> Num

   8expand(8X1,...,8XN) : Any+ -> Any
   8cat(8X1,...,8XN)    : Any+ -> Any
   8stringize(8X)       : Any -> Any

   8emit(8X1,...,8XN)     : Any+ -> Nil
   8emit_cat(8X1,...,8XN) : Any+ -> Nil

First-order functions
---------------------

  -8throw(8X) : Any -> Any

   8exit(8X) : Any -> Any

   8not(8X) : Bool -> Bool

   8inc(8N) : Num -> Num
   8dec(8N) : Num -> Num

   8is_0(8N)   : Num -> Bool
   8isnt_0(8N) : Num -> Bool

   8mod(8LN,8RN) : Num -> Num -> Num
   8div_mod(8LN,8RN) : Num -> Num -> Tuple(Num,Num)

   8equal(8LS,8RS)  : Sym -> Sym -> Bool
   8not_eq(8LS,8RS) : Sym -> Sym -> Bool

   8less(8LN,8RN)       : Num -> Num -> Bool
   8less_eq(8LN,8RN)    : Num -> Num -> Bool
   8greater(8LN,8RN)    : Num -> Num -> Bool
   8greater_eq(8LN,8RN) : Num -> Num -> Bool

Environments
------------

  -8env_nil               : Env
  -8env_has(8EN,8SY)      : Env -> Sym -> Bool
  -8env_ref(8EN,8SY)      : Env -> Sym -> Any
  -8env_bind(8EN,8SY,8VA) : Env -> Sym -> Any -> Env
  -8env_drop(8EN,8SN)     : Env -> Sym -> Env
  -8env_append(8Ep,8ES)   : Env -> Env -> Env

Reflection
----------

  -8call_cc(8FN)  : (Fn -> Any) -> Any
  -8call_ce(8FN)  : (Env -> Any) -> Any
  -8eval(8EX,8EN) : Exp -> Env -> Any

Higher-order functions and operators
------------------------------------

   8chain(8F0,...,8FN) : Fn* -> Fn

  -8for_each(8CN,8ST,8OP,8X) : (Any -> Bool) -> (Any -> Any) -> (Any -> Nil) -> Any -> Nil

   8for_each_in_range(8OP,8FR,8TO) : (Num -> Nil) -> Num -> Num -> Nil

Type predicates
---------------

  -8is_edible(8X) : Any -> Bool
   8is_sym(8X)    : Any -> Bool
   8is_tuple(8X)  : Any -> Bool
   8is_nil(8X)    : Any -> Bool

Macros / Syntax extensions
--------------------------

   8when(<exp_{cond}>, <exp_{body}>+)
   8unless(<exp_{cond}>, <exp_{body}>+)

   8with_assert(<exp_{cond}>, <exp_{body}>)

Tuples
------

   8tuple(8X0,...,8XN) : Any+ -> Tuple
   8tuple_at(8I,8T)    : Num -> Tuple -> Any
   8tuple_size(8T)     : Tuple -> Num
  -8tuple_to_seq(8T)   : Tuple -> Seq

Sequences
---------

  First-order:

   8seq(8X0,...,8XN)            : Any+ -> Seq
  -8seq_append(8S0,...,8SN)     : Seq -> Seq -> Seq
   8seq_at(8I,8S)               : Num -> Seq -> Any
   8seq_first(8S)               : Seq -> Any
   8seq_first_n(8N,8S)          : Num -> Seq -> Seq
   8seq_insert(8I,8S,8X)        : Num -> Seq -> Any -> Seq
  -8seq_insert_range(8I,8S,8SS) : Num -> Seq -> Seq -> Seq
   8seq_pop_back(8S)            : Seq -> Seq
   8seq_pop_front(8S)           : Seq -> Seq
   8seq_push_back(8X,8S)        : Any -> Seq -> Seq
   8seq_push_front(8X,8S)       : Any -> Seq -> Any -> Seq
  -8seq_remove(8I,8S)           : Num -> Seq -> Seq
  -8seq_remove_range(8I,8N,8S)  : Num -> Num -> Seq -> Seq
   8seq_rest(8S)                : Seq -> Seq
   8seq_rest_n(8N,8S)           : Num -> Seq -> Seq
   8seq_reverse(8S)             : Seq -> Seq
   8seq_set(8I,8S,8X)           : Num -> Seq -> Any -> Seq
   8seq_size(8S)                : Seq -> Num
  -8seq_split(8I,8S)            : Num -> Seq -> Tuple(Seq, Seq)
   8seq_range(8I,8N,8S)         : Num -> Num -> Seq -> Seq
   8seq_to_tuple(8S)            : Seq -> Tuple

  Higher-order:

  -8seq_exists(8PR,8S)                      : (Any -> Bool) -> Seq -> Bool
   8seq_filter(8PR,8S)                      : (Any -> Bool) -> Seq -> Seq
   8seq_fold(8FN,8X,8S)                     : (Any -> Any -> Any) -> Any -> Seq -> Any
  -8seq_for_all(8PR,8S)                     : (Any -> Bool) -> Seq -> Bool
   8seq_for_each(8OP,8S)                    : (Any -> Nil) -> Seq -> Nil
   8seq_for_each_in_product(8OP,8SS)        : (Any+ -> Nil) -> Seq(Seq) -> Nil
   8seq_for_each_with_idx(8OP,8S)           : (Num -> Any -> Nil) -> Seq -> Nil
   8seq_map(8FN,8S)                         : (Any -> Any) -> Seq -> Seq
  -8seq_merge(8PR,8LS,8RS)                  : (Any -> Any -> Bool) -> Seq -> Seq -> Seq
  -8seq_parallel_fold(8FN,8S,8SS)           : (Any+ -> Any) -> Seq -> Seq(Seq) -> Any
  -8seq_parallel_for_each(8OP,8SS)          : (Any+ -> Nil) -> Seq(Seq) -> Nil
  -8seq_parallel_for_each_with_idx(8OP,8SS) : (Num -> Any+ -> Nil) -> Seq(Seq) -> Nil
  -8seq_parallel_map(8FN,8SS)               : (Any+ -> Any) -> Seq(Seq) -> Seq
  -8seq_partition(8PR,8S)                   : (Any -> Bool) -> Seq -> Tuple(Seq, Seq)
  -8seq_select(8PR,8X,8S)                   : (Any -> Any -> Bool) -> Any -> Seq -> Any
  -8seq_sort(8PR,8S)                        : (Any -> Any -> Bool) -> Seq -> Seq
  -8seq_unfold(8CN,8ST,8FN,8X)              : (Any -> Bool) -> (Any -> Any) -> (Any -> Any) -> Any -> Seq

--------------------------------------------------------------------------

LIBRARIES
=========

  "hp_arithm.h":

  "enum.h":

  "string.h":
