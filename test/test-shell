#!/bin/bash

# (C) Copyright Vesa Karvonen 2004.
#
# Distributed under the Boost Software License, Version 1.0.

source test-functions

dbFile=test.db

function spacify {
    sed -e 's|,| , |g' \
        -e 's|(| ( |g' \
        -e 's|)| ) |g' \
        -e 's| \+| |g'
}

function sed-from {
    local tmp="$1"
    shift 1
    echo "$tmp" | sed "$@"
}

function test-cnt {
    cat $dbFile | wc -l | sed 's# ##g'
}

function get-line {
    head -n $(($1+1)) | tail -n1
}

function get-line-from {
    echo "$2" | get-line $1
}

function get-test {
    cat $dbFile | get-line $1
}

function add-test {
    echo "$1#$2#<ws>" >> $dbFile
    clean-test-db
}

function clean-test-db {
    local tmp="$(cat $dbFile)"
    echo "$tmp" | sort | uniq > $dbFile
}

function remove-test {
    lines=$(test-cnt)
    before=$(head -n $1 $dbFile)
    after=$(tail -n $(($lines-1-$1)) $dbFile)
    echo -n > $dbFile
    if test "$before" != "" ; then echo "$before" >> $dbFile ; fi
    if test "$after" != "" ; then echo "$after" >> $dbFile ; fi
}

function replace-test {
    lines=$(test-cnt)
    before=$(head -n $1 $dbFile)
    after=$(tail -n $(($lines-1-$1)) $dbFile)
    echo -n > $dbFile
    if test "$before" != "" ; then echo "$before" >> $dbFile ; fi
    add-test "$2" "$3"
    if test "$after" != "" ; then echo "$after" >> $dbFile ; fi
}

function preprocess-all-tests {
    sed -e 's|#.*||g' \
        -e 's|^|ORDER_PP(|g' \
        -e 's|$|)|g' \
        $dbFile | \
    spacify | \
    eval-in | \
    tail -n $(test-cnt)
}

function run-tests {
    echo "Running $(test-cnt) tests..."

    allResult=$(time preprocess-all-tests)
    allTerm=$(sed -e 's|#.*||g' $dbFile)
    allExpected=$(sed -e 's|^[^#]*#||g' -e 's|#.*$||g' $dbFile)

    if test "$allResult" != "$allExpected" ; then
        echo -n "Errors"
        for ((i=0, n=$(test-cnt) ; i < n ; ++i )) ; do
            result=$(get-line-from $i "$allResult")
            term=$(get-line-from $i "$allTerm")
            expected=$(get-line-from $i "$allExpected")

            if test "$expected" != "$result" ; then
                echo
                echo "Term:     $term"
                echo "Expected: $expected"
                echo "Result:   $result"
                read -e -n 1 -p "[(U)se result | (R)emove test | (Q)uit to main menu | Skip]? "
                case "$REPLY" in
                    ("u"|"U")
                        echo -n "Using result"
                        replace-test $i "$term" "$result" ;;
                    ("r"|"R")
                        echo -n "Removing test"
                        remove-test $i ;;
                    ("q"|"Q")
                        echo "Skipping all"
                        i=$n ;;
                    (*)
                        echo "Skipping" ;;
                esac
            else
            echo -n .
            fi
        done
    fi
}

function interactive-eval {
    read -e -p "Term: "
    if test "$REPLY" != "" ; then
        term="$REPLY"
    else
        echo "Term: $term"
    fi
    result=$(time echo "ORDER_PP($term)" | spacify | eval-in | tail -n1)
    resultChars=$(echo "$result" | wc -m | sed 's# ##g')
    resultLines=$(echo "$result" | wc -l | sed 's# ##g')
    if test $(($COLUMNS-9)) -lt $resultChars ; then
        echo "The output contains $resultChars characters on $resultLines lines!"
        read -e -n 1 -p "[(D)isplay | (L)ess | Skip]? "
        case "$REPLY" in
            ("d"|"D")
                echo "Result: $result" ;;
            ("l"|"L")
                echo "Result: $result" | less ;;
            (*)
                echo "Skipping" ;;
        esac
    else
        echo "Result: $result"
    fi
}

function interactive-trace {
    echo "Term: $term"

    steps=0

    result=$(echo "(,,ORDER_PP_DEF($(echo "$term" | spacify)),8EXIT,)" | eval-in)
    echo ": $result"

    while read -e -n 1 -p "[(#$steps) | Enter to step]? " ; do
        if test "$REPLY" != "" ; then
            break
        fi

        steps=$(($steps+1))

        result=$(echo "ORDER_PP_CM_DN_0 $result" | eval-in)
        echo ": $result"

        if ! echo "$result" | grep -q '^(' ; then
            echo "[ Program stopped. ]"
            break
        fi
    done
}

function interactive-add-test {
    interactive-eval
    read -e -n 1 -p "Add [(N)o | Yes]? "
    case "$REPLY" in
        ("n"|"N")
            echo "Not added.";;
        (*)
            add-test "$term" "$result"
            echo "Added." ;;
    esac
}

echo "Database: $dbFile"
if ! cp -r $dbFile $dbFile.bak ; then
    echo "Backup failed. Terminating."
    exit
else
    echo "Backed up database to: $dbFile.bak"
fi

IFS=''

while true ; do
    if test "$#" -gt 0 ; then
        REPLY="$1"
        shift
    else
        read -e -n 1 -p "[(A)dd | (T)est all | (S)how all | (C)lean DB | (Q)uit | (D)ebug | Eval]? "
    fi
    case "$REPLY" in
        ("a"|"A")
            interactive-add-test ;;
        ("-t"|"t"|"T")
            run-tests ;;
        ("s"|"S")
            less $dbFile ;;
        ("c"|"C")
            clean-test-db ;;
        ("-q"|"q"|"Q")
            exit ;;
        ("d"|"D")
            interactive-trace ;;
        (*)
            interactive-eval ;;
    esac
done
